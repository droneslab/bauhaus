extern crate g2o;
use log::{warn, info, debug, error};
use nalgebra::{Isometry3, Vector3, Vector6};
use std::{collections::{BTreeSet, HashMap}, sync::atomic::Ordering, thread::sleep, time::Duration, fmt::Debug};
use gtsam::{
    inference::symbol::Symbol, navigation::combined_imu_factor::{CombinedImuFactor, PreintegratedCombinedMeasurements, PreintegrationCombinedParams}, nonlinear::{
        isam2::ISAM2, nonlinear_factor_graph::NonlinearFactorGraph, values::Values
    },
};
use core::{
    config::*, matrix::*, system::{Actor, MessageBox, System, Timestamp}
};
use crate::{
    actors::{local_mapping_gtsam::LOCAL_MAPPING_IDLE, messages::{ShutdownMsg, UpdateFrameIMUMsg, FeatureTracksAndIMUMsg, TrajectoryMsg, VisTrajectoryMsg, VisTrajectoryTrackingMsg}, tracking_frontend_gtsam::TrackedFeatures},
    map::{frame::Frame, map::Id, pose::Pose, read_only_lock::ReadWriteMap}, modules::imu::{ImuBias, ImuCalib, ImuMeasurements}, registered_actors::{IMU, SHUTDOWN_ACTOR, TRACKING_FRONTEND, VISUALIZER}, ImuInitializationData
};

pub struct TrackingBackendGTSAM {
    system: System,
    map: ReadWriteMap,

    // Last kf/frame
    last_kf_id: Id,
    last_kf_pose: Pose,
    last_timestamp: Timestamp,
    last_kf_imu_bias: ImuBias,
    last_feature_tracks: TrackedFeatures,

    // Modules 
    graph_solver: GraphSolver,

    // Poses in trajectory
    trajectory_poses: Vec<Pose>, //mlRelativeFramePoses

    frames_since_last_kf: i32,
}

impl Actor for TrackingBackendGTSAM {
    type MapRef = ReadWriteMap;

    fn spawn(system: System, map: Self::MapRef) {
        let mut actor = TrackingBackendGTSAM {
            system,
            graph_solver: GraphSolver::new(),
            // sensor,
            map,
            trajectory_poses: Vec::new(),
            last_kf_id: -1,
            last_timestamp: 0.0,
            last_kf_pose: Pose::default(),
            last_kf_imu_bias: ImuBias::new(),
            last_feature_tracks: TrackedFeatures::default(),
            frames_since_last_kf: 0,
        };
        tracy_client::set_thread_name!("tracking backend gtsam");

        loop {
            let message = actor.system.receive().unwrap();
            if actor.handle_message(message) {
                break;
            }
            actor.map.match_map_version();
        }
    }

}

impl TrackingBackendGTSAM {
    fn handle_message(&mut self, message: MessageBox) -> bool {
        if message.is::<FeatureTracksAndIMUMsg>() {
            if self.system.queue_full() {
                // Abort additional work if there are too many frames in the msg queue.
                info!("Tracking gtsam dropped 1 frame");
                return false;
            }

            let msg = message.downcast::<FeatureTracksAndIMUMsg>().unwrap_or_else(|_| panic!("Could not downcast tracking message!"));
            self.handle_regular_message(*msg).unwrap();
        } else if message.is::<UpdateFrameIMUMsg>() {
            warn!("I think it may be ok to ignore this because the bias is always set to the ref kf, and local mapping should have done that already");

        } else if message.is::<ShutdownMsg>() {
            // Sleep a little to allow other threads to finish
            sleep(Duration::from_millis(100));
            return true;
        } else {
            warn!("Tracking backend received unknown message type!");
        }
        return false;
    }

    fn handle_regular_message(&mut self, mut msg: FeatureTracksAndIMUMsg) -> Result<(), Box<dyn std::error::Error>> {
        let _span = tracy_client::span!("track");

        if self.last_kf_id == -1 {
            // First frame received here... was already put into local mapping map as latest keyframe
            // Need to initialize the factor graph 

            // Initialize from gt
            let imu_init = msg.imu_initialization.expect("Msg should have imu initialization data!");
            self.graph_solver.initialize_with_data(
                (msg.frame.timestamp * 1e9) as i64,
                &imu_init
            ).expect("Failed to initialize?");


            // Initialize from map initialization
            // let map = self.map.read()?;
            // let kf0 = map.get_keyframe(0);
            // let kf1 = map.get_keyframe(1);
            // let kf0_pose = kf0.get_pose();
            // let kf1_pose = kf1.get_pose();

            // let velocity = DVVector3::new(
            //     (*kf1_pose.get_translation() - *kf0_pose.get_translation()) / (kf1.timestamp - kf0.timestamp)
            // );

            // let trans_imu = *kf1_pose.inverse().get_rotation() * *ImuCalib::new().tcb.get_translation() + *kf1_pose.inverse().get_translation();
            // let rot_imu =  *kf1_pose.inverse().get_rotation() * *ImuCalib::new().tcb.get_rotation();
            // let pose_imu = Pose::new(trans_imu, rot_imu);

            // self.graph_solver.initialize(
            //     (msg.frame.timestamp * 1e9) as i64,
            //     pose_imu,
            //     velocity,
            //     ImuBias {
            //         bax: imu_init.acc_bias[0],
            //         bay: imu_init.acc_bias[1],
            //         baz: imu_init.acc_bias[2],
            //         bwx: imu_init.gyro_bias[0],
            //         bwy: imu_init.gyro_bias[1],
            //         bwz: imu_init.gyro_bias[2]
            //     }
            // )?;

            self.graph_solver.solver_state = GraphSolverState::Ok;
            self.last_timestamp = msg.frame.timestamp;
            self.last_kf_id = 1;
            self.last_kf_pose = msg.frame.pose.unwrap();
            self.last_kf_imu_bias = ImuBias {
                bax: imu_init.acc_bias[0],
                bay: imu_init.acc_bias[1],
                baz: imu_init.acc_bias[2],
                bwx: imu_init.gyro_bias[0],
                bwy: imu_init.gyro_bias[1],
                bwz: imu_init.gyro_bias[2]
            };

        } else {
            // If we have previous frames already, can track normally
            let mut current_frame = msg.frame;

            // Solve VIO graph. Includes preintegration
            let optimized = self.graph_solver.solve(
                &mut current_frame,
                &mut msg.imu_measurements, &msg.feature_tracks
            )?;
            if !optimized {
                warn!("Could not optimize graph");
            }

            current_frame.ref_kf_id = Some(self.last_kf_id);
            self.update_trajectory_in_logs(& current_frame).expect("Could not save trajectory");
            self.last_timestamp = current_frame.timestamp;
            self.last_kf_pose = current_frame.pose.unwrap();
            self.last_kf_id += 1;
            self.last_kf_imu_bias = current_frame.imu_data.imu_bias;


            if self.need_new_keyframe(msg.feature_tracks.len() as u32) {
                self.frames_since_last_kf = 0;
                // SOFIYA TURN OFF LOCAL MAPPING
                // println!("TRACKING BACKEND SEND TO LOCAL MAPPING");

                // // KeyFrame created here and inserted into map
                // self.system.send(
                //     LOCAL_MAPPING,
                //     Box::new( NewKeyFrameGTSAMMsg{
                //         tracking_state: TrackingState::Ok,
                //         keyframe: current_frame,
                //         map_version: self.map.read()?.version
                //     } )
                // );
            } else {
                self.frames_since_last_kf += 1;
            }
        }

        self.last_feature_tracks = msg.feature_tracks;

        return Ok(());
    }

    fn update_trajectory_in_logs(
        &mut self, current_frame: &Frame,
    ) -> Result<(), Box<dyn std::error::Error>> {
        self.trajectory_poses.push(current_frame.pose.unwrap());

        self.system.send(
            SHUTDOWN_ACTOR, 
            Box::new(TrajectoryMsg{
                pose: current_frame.pose.unwrap(),
                ref_kf_id: current_frame.ref_kf_id.unwrap(),
                timestamp: current_frame.timestamp,
                map_version: self.map.read()?.version
            })
        );

        let map = self.map.read()?;
        self.system.try_send(VISUALIZER, Box::new(VisTrajectoryMsg{
            pose: current_frame.pose.unwrap(),
            mappoint_matches: vec![],
            mappoints_in_tracking: BTreeSet::new(),
            timestamp: current_frame.timestamp,
            map_version: map.version
        }));
        self.system.try_send(VISUALIZER, Box::new(VisTrajectoryTrackingMsg{
            pose: current_frame.pose.unwrap(),
            timestamp: current_frame.timestamp,
            map_version: map.version
        }));


        Ok(())
    }

    fn need_new_keyframe(&mut self, tracked_features: u32) -> bool {
        // Condition 1a: More than "MaxFrames" have passed from last keyframe insertion
        let c1a = self.frames_since_last_kf >= (SETTINGS.get::<i32>(TRACKING_FRONTEND, "max_frames_to_insert_kf") as i32);
        // Condition 1b: More than "MinFrames" have passed and Local Mapping is idle
        let c1b = self.frames_since_last_kf >= (SETTINGS.get::<i32>(TRACKING_FRONTEND, "min_frames_to_insert_kf") as i32) && LOCAL_MAPPING_IDLE.load(Ordering::SeqCst);
        //Condition 1c: tracking is weak
        let c1c = tracked_features < (SETTINGS.get::<i32>(TRACKING_FRONTEND, "min_num_features") as u32);

        // let c1c = ((self.matches_inliers as f32) < tracked_mappoints * 0.5 || need_to_insert_close) ;
        // // Condition 2: Few tracked points compared to reference keyframe. Lots of visual odometry compared to map matches.
        // let c2 = (((self.matches_inliers as f32) < (tracked_mappoints * th_ref_ratio) || need_to_insert_close)) && self.matches_inliers > 15;
        // (c1a||c1b||c1c) && c2

        debug!("Need new keyframe? {} {} {}, {}", c1a, c1b, c1c, tracked_features);

        c1a || c1b || c1c
    }

}

pub struct GraphSolver {
    solver_state: GraphSolverState,

    // New graph
    graph_new: NonlinearFactorGraph, // New factors that have not been optimized yet
    values_new: Values, // New values that have not been optimized yet

    // Main graph
    // graph_main: NonlinearFactorGraph, // Main non-linear GTSAM graph, all created factors
    values_initial: Values, // All created nodes

    // Misc GTSAM objects
    isam2: ISAM2, // ISAM2 solvers
    preint_gtsam: PreintegratedCombinedMeasurements, // IMU preintegration

    // Initialization
    accel_noise_density: f64, // accelerometer_noise_density, sigma_a
    gyro_noise_density: f64, // gyroscope_noise_density, sigma_g
    accel_random_walk: f64, // accelerometer_random_walk, sigma_wa
    gyro_random_walk: f64, // gyroscope_random_walk, sigma_wg
    sigma_camera: f64,

    // Kimera
    // Noise values for initialization
    initial_position_sigma: f64,
    initial_roll_pitch_sigma: f64,
    initial_yaw_sigma: f64,
    initial_velocity_sigma: f64,
    initial_acc_bias_sigma: f64,
    initial_gyro_bias_sigma: f64,
    imu_integration_sigma: f64,
    init_bias_sigma: f64,

    // Iterations of the map
    ct_state: u64,
    ct_state_lookup: HashMap<i64, u64>,
    timestamp_lookup: HashMap<u64, i64>,
    measurement_smart_lookup_left: HashMap<i32, gtsam::slam::projection_factor::SmartProjectionPoseFactorCal3S2>, // Smart lookup for IMU measurements
}

impl GraphSolver {
    pub fn new() -> Self {
        Self {
            graph_new: NonlinearFactorGraph::default(),
            values_new: Values::default(),
            // graph_main: NonlinearFactorGraph::default(),
            values_initial: Values::default(),
            isam2: ISAM2::default(),
            preint_gtsam: PreintegratedCombinedMeasurements::default(),
            solver_state: GraphSolverState::NotInitialized,

            sigma_camera: 0.306555403,
            initial_position_sigma: SETTINGS.get::<f64>(IMU, "initialPositionSigma"),
            initial_roll_pitch_sigma: SETTINGS.get::<f64>(IMU, "initialRollPitchSigma"),
            initial_yaw_sigma: SETTINGS.get::<f64>(IMU, "initialYawSigma"),
            initial_velocity_sigma: SETTINGS.get::<f64>(IMU, "initialVelocitySigma"),
            initial_acc_bias_sigma: SETTINGS.get::<f64>(IMU, "initialAccBiasSigma"),
            initial_gyro_bias_sigma: SETTINGS.get::<f64>(IMU, "initialGyroBiasSigma"),
            accel_noise_density: SETTINGS.get::<f64>(IMU, "noise_acc"),
            gyro_noise_density: SETTINGS.get::<f64>(IMU, "noise_gyro"),
            accel_random_walk: SETTINGS.get::<f64>(IMU, "acc_walk"),
            gyro_random_walk: SETTINGS.get::<f64>(IMU, "gyro_walk"),
            imu_integration_sigma: SETTINGS.get::<f64>(IMU, "imu_integration_sigma"),
            init_bias_sigma: SETTINGS.get::<f64>(IMU, "imu_bias_init_sigma"),

            ct_state: 0,
            ct_state_lookup: HashMap::new(),
            timestamp_lookup: HashMap::new(),
            measurement_smart_lookup_left: HashMap::new(),
        }
    }

    fn solve(&mut self,
        current_frame : &mut Frame, 
        imu_measurements : &mut ImuMeasurements, new_tracked_features : &TrackedFeatures
    ) -> Result<bool, Box<dyn std::error::Error>> {
        let _span = tracy_client::span!("solve");

        let timestamp = (current_frame.timestamp * 1e9) as i64; // Convert to int just so we can hash it

        // Return if the node already exists in the graph
        if self.ct_state_lookup.contains_key(&timestamp) {
            warn!("NODE WITH TIMESTAMP {} ALREADY EXISTS", timestamp);
            return Ok(false);
        }

        self.create_imu_factor(imu_measurements)?;

        // Original models
        let new_state = self.predict_state();

        // Move node count forward in time
        self.ct_state += 1;

        // Append to our node vectors
        self.values_new.insert_pose3(
            &Symbol::new(b'x', self.ct_state),
            &new_state.pose
        );
        self.values_new.insert_vector3(
            &Symbol::new(b'v', self.ct_state),
            &new_state.velocity
        );
        self.values_new.insert_constant_bias(
            &Symbol::new(b'b', self.ct_state),
            &new_state.bias
        );
        self.values_initial.insert_pose3(
            &Symbol::new(b'x', self.ct_state),
            &new_state.pose
        );
        self.values_initial.insert_vector3(
            &Symbol::new(b'v', self.ct_state),
            &new_state.velocity
        );
        self.values_initial.insert_constant_bias(
            &Symbol::new(b'b', self.ct_state),
            &new_state.bias
        );

        // Add ct state to map
        self.ct_state_lookup.insert(timestamp, self.ct_state);
        self.timestamp_lookup.insert(self.ct_state, timestamp);

        self.process_smart_features(new_tracked_features);

        debug!("IMU POSE ESTIMATE... {}, {:?}, {:?}, {:?}", timestamp, new_state.pose, new_state.velocity, new_state.bias);

        self.optimize();
        // Update frame with optimized values
        // TODO there's probably a better way to clean up all this conversion than this
        let updated_pose: Isometry3<f64> = self.values_initial.get_pose3(&Symbol::new(b'x', self.ct_state)).unwrap().into();
        current_frame.pose = Some(Pose::new_from_isometry(updated_pose));
        let velocity: gtsam::base::vector::Vector3 = self.values_initial.get_vector3(&Symbol::new(b'v', self.ct_state)).unwrap().into();
        let vel_raw = velocity.get_raw();
        current_frame.imu_data.velocity = Some(DVVector3::new_with(vel_raw[0], vel_raw[1], vel_raw[2]));
        let bias_ref = self.values_initial.get_constantbias(&Symbol::new(b'b', self.ct_state)).unwrap();
        let accel_bias = bias_ref.accel_bias().get_raw();
        let gyro_bias = bias_ref.gyro_bias().get_raw();

        // TODO SOFIYA Should this be set_new_bias?
        current_frame.imu_data.imu_bias = ImuBias {
            bax: accel_bias[0],
            bay: accel_bias[1],
            baz: accel_bias[2],
            bwx: gyro_bias[0],
            bwy: gyro_bias[1],
            bwz: gyro_bias[2]
        };
        debug!("OPTIMIZED POSE ESTIMATE... {}, {:?}, {:?}, {:?}", timestamp, updated_pose, velocity, current_frame.imu_data.imu_bias);

        Ok(true)
    }

    fn initialize_with_data(&mut self, timestamp: i64, imu_init: &ImuInitializationData) -> Result<(), Box<dyn std::error::Error>> {
        let init_pose = Pose::new_with_quaternion_convert(*imu_init.translation, imu_init.rotation);
        let init_bias = ImuBias::new_with(imu_init.gyro_bias, imu_init.acc_bias);
        self.initialize(timestamp, init_pose, imu_init.velocity, init_bias)
    }

    fn initialize(&mut self, timestamp: i64, init_pose: Pose, init_vel: DVVector3<f64>, init_bias: ImuBias) -> Result<(), Box<dyn std::error::Error>> {
        println!("... Initial pose: {:?}", init_pose);
        println!("... Initial velocity: {:?}", init_vel);
        println!("... Initial bias: {:?}", init_bias);

        // Create prior factor and add it to the graph
        let prior_state = {
            let trans = init_pose.translation;
            let rot = init_pose.get_quaternion();
            GtsamState {
                pose: gtsam::geometry::pose3::Pose3::from_parts(
                    gtsam::geometry::point3::Point3::new(trans.x, trans.y, trans.z),
                    gtsam::geometry::rot3::Rot3::from(rot)
                ),
                velocity: gtsam::base::vector::Vector3::new(init_vel[0], init_vel[1], init_vel[2]),
                bias: gtsam::imu::imu_bias::ConstantBias::new(
                    &gtsam::base::vector::Vector3::new(init_bias.bax, init_bias.bay, init_bias.baz),
                    &gtsam::base::vector::Vector3::new(init_bias.bwx, init_bias.bwy, init_bias.bwz)
                )
            }
        };

        // Set initial pose uncertainty: constrain mainly position and global yaw.
        // roll and pitch is observable, therefore low variance.

        let mut pose_prior_covariance2 = nalgebra::Matrix3::zeros();
        pose_prior_covariance2[(0, 0)] = self.initial_roll_pitch_sigma * self.initial_roll_pitch_sigma;
        pose_prior_covariance2[(1, 1)] = self.initial_roll_pitch_sigma * self.initial_roll_pitch_sigma;
        pose_prior_covariance2[(2, 2)] = self.initial_yaw_sigma * self.initial_yaw_sigma;

        // Rotate initial uncertainty into local frame, where the uncertainty is
        // specified.
        let b_rot_w = init_pose.get_rotation().transpose();
        pose_prior_covariance2 = b_rot_w * pose_prior_covariance2 * b_rot_w.transpose();

        let mut pose_prior_covariance = nalgebra::Matrix6::zeros();
        pose_prior_covariance[(0, 0)] = pose_prior_covariance2[(0,0)];
        pose_prior_covariance[(0, 1)] = pose_prior_covariance2[(0,1)];
        pose_prior_covariance[(0, 2)] = pose_prior_covariance2[(0,2)];
        pose_prior_covariance[(1, 0)] = pose_prior_covariance2[(1,0)];
        pose_prior_covariance[(1, 1)] = pose_prior_covariance2[(1,1)];
        pose_prior_covariance[(1, 2)] = pose_prior_covariance2[(1,2)];
        pose_prior_covariance[(2, 0)] = pose_prior_covariance2[(2,0)];
        pose_prior_covariance[(2, 1)] = pose_prior_covariance2[(2,1)];
        pose_prior_covariance[(2, 2)] = pose_prior_covariance2[(2,2)];
        pose_prior_covariance[(3, 3)] = self.initial_position_sigma * self.initial_position_sigma;
        pose_prior_covariance[(4, 4)] = self.initial_position_sigma * self.initial_position_sigma;
        pose_prior_covariance[(5, 5)] = self.initial_position_sigma * self.initial_position_sigma;

        // Add pose prior.
        let pose_noise = gtsam::linear::noise_model::GaussianNoiseModel::from_covariance(pose_prior_covariance);
        // let pose_noise = gtsam::linear::noise_model::DiagonalNoiseModel::from_sigmas(Vector6::new(
        //     self.initial_roll_pitch_sigma,
        //     self.initial_roll_pitch_sigma,
        //     self.initial_yaw_sigma,
        //     self.initial_position_sigma,
        //     self.initial_position_sigma,
        //     self.initial_position_sigma
        // ));
        self.graph_new.add_prior_factor_pose3(&Symbol::new(b'x', self.ct_state), &prior_state.pose, &pose_noise);

        let v_noise = gtsam::linear::noise_model::IsotropicNoiseModel::from_dim_and_sigma(3, self.initial_velocity_sigma);
        self.graph_new.add_prior_factor_vector3(&Symbol::new(b'v', self.ct_state), &prior_state.velocity, &v_noise);

        let b_noise = gtsam::linear::noise_model::DiagonalNoiseModel::from_sigmas(Vector6::new(
            self.initial_acc_bias_sigma,
            self.initial_acc_bias_sigma,
            self.initial_acc_bias_sigma,
            self.initial_gyro_bias_sigma,
            self.initial_gyro_bias_sigma,
            self.initial_gyro_bias_sigma,
        ));
        self.graph_new.add_prior_factor_constant_bias_diagonal(&Symbol::new(b'b', self.ct_state), &prior_state.bias, &b_noise);

        // self.graph_main.add_prior_factor_pose3(&Symbol::new(b'x', self.ct_state), &prior_state.pose, &pose_noise);
        // self.graph_main.add_prior_factor_vector3(&Symbol::new(b'v', self.ct_state), &prior_state.velocity, &v_noise);
        // self.graph_main.add_prior_factor_constant_bias_diagonal(&Symbol::new(b'b', self.ct_state), &prior_state.bias, &b_noise);

        // Add initial state to the graph
        self.values_new.insert_pose3(&Symbol::new(b'x', self.ct_state), &prior_state.pose);
        self.values_new.insert_vector3(&Symbol::new(b'v', self.ct_state), &prior_state.velocity);
        self.values_new.insert_constant_bias(&Symbol::new(b'b', self.ct_state), &prior_state.bias);
        self.values_initial.insert_pose3(&Symbol::new(b'x', self.ct_state), &prior_state.pose);
        self.values_initial.insert_vector3(&Symbol::new(b'v', self.ct_state), &prior_state.velocity);
        self.values_initial.insert_constant_bias(&Symbol::new(b'b', self.ct_state), &prior_state.bias);

        // Add ct state to map
        self.ct_state_lookup.insert(timestamp, self.ct_state);
        self.timestamp_lookup.insert(self.ct_state, timestamp);

        // Create GTSAM preintegration parameters for use with Foster's version
        let mut params = PreintegrationCombinedParams::makesharedu();  // Z-up navigation frame: gravity points along negative Z-axis !!!
        params.set_gyroscope_covariance(self.gyro_noise_density * self.gyro_noise_density);
        params.set_accelerometer_covariance(self.accel_noise_density * self.accel_noise_density);
        params.set_integration_covariance(self.imu_integration_sigma * self.imu_integration_sigma);
        params.set_bias_acc_omega_int(self.init_bias_sigma);
        params.set_bias_acc_covariance(self.accel_random_walk * self.accel_random_walk);
        params.set_bias_omega_covariance(self.gyro_random_walk * self.gyro_random_walk);

        // Actually create the GTSAM preintegration
        self.preint_gtsam = PreintegratedCombinedMeasurements::new(params, &prior_state.bias);
        Ok(())
    }

    fn predict_state(&self) -> GtsamState {
        let _span = tracy_client::span!("get_predicted_state");
        // This function will get the predicted state based on the IMU measurement

        // Get the current state (t=k)
        let state_k = GtsamState {
            pose: self.values_initial.get_pose3(&Symbol::new(b'x', self.ct_state)).unwrap().into(),
            velocity: self.values_initial.get_vector3(&Symbol::new(b'v', self.ct_state)).unwrap().into(),
            bias: self.values_initial.get_constantbias(&Symbol::new(b'b', self.ct_state)).unwrap().into()
        };

        debug!("Current state used for imu-based prediction: {:?}", state_k);

        // From this we should predict where we will be at the next time (t=K+1)
        let state_k1 = self.preint_gtsam.predict(
            &gtsam::navigation::navstate::NavState::new(
                &state_k.pose,
                &state_k.velocity
            ),
            &state_k.bias
        );

        let predicted = GtsamState {
	    // This is a required pose for the interpolation1
            pose: state_k1.get_pose().into(),
            velocity: state_k1.get_velocity().into(),
            bias: state_k.bias
        };

        return predicted;
    }

    fn create_imu_factor(&mut self, imu_measurements: &mut ImuMeasurements) -> Result<(), Box<dyn std::error::Error>> {
        // This function will create a discrete IMU factor using the GTSAM preintegrator class
        // This will integrate from the current state time up to the new update time
        let _span = tracy_client::span!("create_imu_factor");

        // println!("Imu measurements: {:?}", imu_measurements);

        // From ORBSLAM:
        // let mut imu_from_last_frame = VecDeque::with_capacity(imu_measurements.len()); // mvImuFromLastFrame
        // let imu_per = 0.001;
        // while !imu_measurements.is_empty() {
        //     if imu_measurements.front().unwrap().timestamp < last_timestamp - imu_per {
        //         imu_measurements.pop_front();
        //     } else if imu_measurements.front().unwrap().timestamp < current_frame.timestamp - imu_per {
        //         let msmt = imu_measurements.pop_front().unwrap();
        //         imu_from_last_frame.push_back(msmt);
        //     } else {
        //         let msmt = imu_measurements.pop_front().unwrap();
        //         imu_from_last_frame.push_back(msmt);
        //         break;
        //     }
        // }
        // let n = imu_from_last_frame.len() - 1;

        // ORBSLAM3 imu preintegrated object. If not doing imu-based optimizations in local mapping and loop closure, don't need this
        // let mut other_imu = IMU::new();
        // let mut imu_preintegrated_from_last_frame = ImuPreIntegrated::new(last_frame_imu_bias);

        for i in 0..imu_measurements.len()-1 {
        // Commented out code here from ORBSLAM3 as well
        // for i in 0..n {
            let mut tstep = imu_measurements[i + 1].timestamp - imu_measurements[i].timestamp;
            let mut acc: Vector3<f64> = imu_measurements[i].acc; // acc
            let mut ang_vel: Vector3<f64> = imu_measurements[i].ang_vel; // angVel
            // let mut tstep = 0.0;
            // let mut acc: Vector3<f64> = Vector3::zeros(); // acc
            // let mut ang_vel: Vector3<f64> = Vector3::zeros(); // angVel

            // // orbslam:
            // if i == 0 && i < (n - 1) {
            //     let tab = imu_from_last_frame[i + 1].timestamp - imu_from_last_frame[i].timestamp;
            //     let tini = imu_from_last_frame[i].timestamp - last_timestamp;
            //     acc = (
            //         imu_from_last_frame[i].acc + imu_from_last_frame[i + 1].acc -
            //         (imu_from_last_frame[i + 1].acc - imu_from_last_frame[i].acc) * (tini/tab)
            //     ) * 0.5;
            //     ang_vel = (
            //         imu_from_last_frame[i].ang_vel + imu_from_last_frame[i + 1].ang_vel -
            //         (imu_from_last_frame[i + 1].ang_vel - imu_from_last_frame[i].ang_vel) * (tini/tab)
            //     ) * 0.5;
            //     tstep = imu_from_last_frame[i + 1].timestamp - last_timestamp;
            // } else if i < (n - 1) {
            //     acc = (imu_from_last_frame[i].acc + imu_from_last_frame[i + 1].acc) * 0.5;
            //     ang_vel = (imu_from_last_frame[i].ang_vel + imu_from_last_frame[i + 1].ang_vel) * 0.5;
            //     tstep = imu_from_last_frame[i + 1].timestamp - imu_from_last_frame[i].timestamp;
            // } else if i > 0 && i == (n - 1) {
            //     let tab = imu_from_last_frame[i + 1].timestamp - imu_from_last_frame[i].timestamp;
            //     let tend = imu_from_last_frame[i + 1].timestamp - current_frame.timestamp;
            //     acc = (
            //         imu_from_last_frame[i].acc + imu_from_last_frame[i + 1].acc -
            //         (imu_from_last_frame[i + 1].acc - imu_from_last_frame[i].acc) * (tend/tab)
            //     ) * 0.5;
            //     ang_vel = (
            //         imu_from_last_frame[i].ang_vel + imu_from_last_frame[i + 1].ang_vel -
            //         (imu_from_last_frame[i + 1].ang_vel - imu_from_last_frame[i].ang_vel) * (tend/tab)
            //     ) * 0.5;
            //     tstep = current_frame.timestamp - imu_from_last_frame[i].timestamp;
            // } else if i == 0 && i == (n - 1) {
            //     acc = imu_from_last_frame[i].acc;
            //     ang_vel = imu_from_last_frame[i].ang_vel;
            //     tstep = current_frame.timestamp - last_timestamp;
            // }
            // tstep = tstep * 1e9;

            self.preint_gtsam.integrate_measurement(&acc.into(), &ang_vel.into(), tstep);

            // ORBSLAM3 imu preintegrated object
            // other_imu.imu_preintegrated_from_last_kf.integrate_new_measurement(acc, ang_vel, tstep);
            // imu_preintegrated_from_last_frame.integrate_new_measurement(acc, ang_vel, tstep);
        }

        let imu_factor = CombinedImuFactor::new(
            &Symbol::new(b'x', self.ct_state),
            &Symbol::new(b'v', self.ct_state),
            &Symbol::new(b'x', self.ct_state + 1),
            &Symbol::new(b'v', self.ct_state + 1),
            &Symbol::new(b'b', self.ct_state),
            &Symbol::new(b'b', self.ct_state + 1),
            & self.preint_gtsam
        );
        self.graph_new.add_combined_imu_factor(&imu_factor);
        // self.graph_main.add_combined_imu_factor(&imu_factor);

        // ORBSLAM3 imu preintegrated object
        // current_frame.imu_data.imu_preintegrated = Some(other_imu.imu_preintegrated_from_last_kf.clone());
        // current_frame.imu_data.imu_preintegrated_frame = Some(imu_preintegrated_from_last_frame);
        // current_frame.imu_data.prev_keyframe = Some(last_kf_id);
        // other_imu.predict_state_last_keyframe(&map, current_frame, last_kf_id)?;

        Ok(())
    }

    fn process_smart_features(&mut self, new_tracked_features: &TrackedFeatures) {
        let _span = tracy_client::span!("process_smart_features");

        for i in 0..new_tracked_features.len() - 1 {
            let feature_id = new_tracked_features.get_feature_id(i as usize);
            if feature_id == -1 {
                continue;
            }
            let point = new_tracked_features.get_point(i as usize);

            // Check to see if it is already in the graph
            match self.measurement_smart_lookup_left.get_mut(&feature_id) {
                Some(smartfactor) => {
                    // Insert measurements to a smart factor
                    smartfactor.add(
                        & gtsam::geometry::point2::Point2::new(point.x as f64, point.y as f64),
                        &Symbol::new(b'x', self.ct_state)
                    );
                    continue;
                },
                None => {
                    // If we know it is not in the graph
                    // Create a smart factor for the new feature
                    let measurement_noise = gtsam::linear::noise_model::IsotropicNoiseModel::from_dim_and_sigma(2, self.sigma_camera);
                    let k = gtsam::geometry::cal3_s2::Cal3S2::default();

                    // Transformation from camera frame to imu frame, i.e., pose of imu frame in camera frame
                    let sensor_p_body = ImuCalib::new().tbc;

                    let mut smartfactor_left = gtsam::slam::projection_factor::SmartProjectionPoseFactorCal3S2::new(
                        &measurement_noise,
                        &k,
                        & sensor_p_body.inverse().into()
                    );

                    // Insert measurements to a smart factor
                    smartfactor_left.add(
                        & gtsam::geometry::point2::Point2::new(point.x as f64, point.y as f64),
                        &Symbol::new(b'x', self.ct_state)
                    );

                    // Add smart factor to FORSTER2 model
                    self.graph_new.add_smartfactor(&smartfactor_left);
                    // self.graph_main.add_smartfactor(&smartfactor_left);

                    self.measurement_smart_lookup_left.insert(feature_id, smartfactor_left);
                }
            }
        }
    }

    fn optimize(&mut self) {
        let _span = tracy_client::span!("optimize");

        // Perform smoothing update
        self.isam2.update_noresults(& self.graph_new, & self.values_new);
        self.values_initial = self.isam2.calculate_estimate().into();

        // Remove the used up nodes
        self.values_new.clear();

        // Remove the used up factors
        self.graph_new.resize(0);

        // Use the optimized bias to reset integration
        if self.values_initial.exists(&Symbol::new(b'b', self.ct_state)) {
            self.preint_gtsam.reset_integration_and_set_bias(
                & self.values_initial.get_constantbias(&Symbol::new(b'b', self.ct_state)).unwrap().into()
            );
        } else {
            warn!("Bias wasn't optimized?");
        }
    }
}


#[derive(Debug)]
struct GtsamState {
    pub pose: gtsam::geometry::pose3::Pose3,
    pub velocity: gtsam::base::vector::Vector3,
    pub bias: gtsam::imu::imu_bias::ConstantBias,
}

#[derive(Clone)]
enum GraphSolverState {
    NotInitialized,
    Ok
}
