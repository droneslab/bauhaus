use std::{sync::Arc, path::Path, any::Any};
use std::{collections::BTreeMap, fs, io::BufWriter};

// use axiom::{message::ActorMessage, prelude::*};
use dvcore::{matrix::*, base::{ActorMessage, ActorChannels, Actor},};
use log::warn;
use mcap::Schema;
// use opencv::{imgcodecs, viz::WCloud};
use mcap::{Channel, records::MessageHeader, Writer};
use opencv::prelude::Mat;

use crate::modules::image;
use crate::{
    actors::messages::{ImageMsg}, 
    dvmap::{map::Map, pose::{Translation, Rotation, Pose}},
    lockwrap::ReadOnlyWrapper
};

use super::messages::{ShutdownMessage, ImagePathMsg};


// #[derive(Debug)]
pub struct DarvisVisualizer<'a> {
    actor_system: ActorChannels,
    map: ReadOnlyWrapper<Map>,
    writer: Writer<'a, BufWriter<fs::File>>,
    image_channel_id: u16,
}

impl<'a> Actor for DarvisVisualizer<'a> {
    fn run(&mut self) {
        loop {
            let message = self.actor_system.receive().unwrap();

            if let Some(msg) = message.downcast_ref::<ImagePathMsg>() {
                let image = self.draw_image(msg).expect("Visualizer could not draw image!");
                self.send_image_to_frontend(image);
            } else if let Some(msg) = message.downcast_ref::<VisFeaturesMsg>() {
                self.draw_features(msg).expect("Visualizer could not draw features!");
            } else if let Some(msg) = message.downcast_ref::<VisKeyFrameMsg>() {
                self.draw_new_keyframe(msg).expect("Visualizer could not draw keyframe!");
            } else if let Some(msg) = message.downcast_ref::<VisMapPointsMsg>() {
                self.draw_mappoints(msg).expect("Visualizer could not draw mappoints!");
            } else if let Some(_) = message.downcast_ref::<ShutdownMessage>() {
                self.writer.finish().expect("Could not close file");
                break;
            } else {
                warn!("Visualizer received unknown message type!");
            }

        }
    }
}

impl<'a> DarvisVisualizer<'a> {
    pub fn new(actor_system: ActorChannels, map: ReadOnlyWrapper<Map>) -> DarvisVisualizer<'a> {
        let mut writer = Writer::new(
            BufWriter::new(fs::File::create("results/out.mcap")
                .expect("Could not create BufWriter for mcap file"))
        ).expect("Could not create Writer for mcap file!");

        // Channels and schemas are automatically assigned ID as they're serialized,
        // and automatically deduplicated with `Arc` when deserialized.
//         let schema = Schema {
//             name: "foxglove_msgs/RawImage".to_string(),
//             encoding: "ros1msg".to_string(),
//             data: "# foxglove_msgs/RawImage
// # A raw image

// # Generated by https://github.com/foxglove/schemas

// # Timestamp of image
// time timestamp

// # Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
// string frame_id

// # Image width
// uint32 width

// # Image height
// uint32 height

// # Encoding of the raw image data
// # 
// # Supported values: `8UC1`, `8UC3`, `16UC1`, `32FC1`, `bayer_bggr8`, `bayer_gbrg8`, `bayer_grbg8`, `bayer_rggb8`, `bgr8`, `bgra8`, `mono8`, `mono16`, `rgb8`, `rgba8`, `uyvy` or `yuv422`, `yuyv` or `yuv422_yuy2`
// string encoding

// # Byte length of a single row
// uint32 step

// # Raw image data
// uint8[] data".to_string()
//         };
//         let image_channel = Channel {
//             topic: String::from("/image"),
//             schema: Some(Arc::new(schema)),
//             message_encoding: String::from("ros1"),
//             metadata: BTreeMap::default()
//         };
//         let image_channel_id = writer.add_channel(&image_channel).expect("Could not add channel");

//         // let odom_channel = Channel {
//         //     topic: String::from("odom"),
//         //     schema: None,
//         //     message_encoding: String::from("application/octet-stream"),
//         //     metadata: BTreeMap::default()
//         // };
//         // let image_channel_id = writer.add_channel(&odom_channel).expect("Could not add channel");

//         return DarvisVisualizer{
//             actor_system,
//             map,
//             writer,
//             image_channel_id,
//         };
        todo!()
    }


    pub fn draw_image(&mut self, message: &ImagePathMsg) -> Result<Mat, Box<dyn std::error::Error>> {
        let image = image::read_image_file(&message.image_path);

        self.writer.write_to_known_channel(
            &MessageHeader {
                channel_id: self.image_channel_id,
                sequence: 25,
                log_time: 6,
                publish_time: 24
            },
            &[1, 2, 3]
        )?;
        // todo!()
        Ok(image)
    }

    pub fn draw_features(&mut self, message: &VisFeaturesMsg) -> Result<(), Box<dyn std::error::Error>> {
        todo!()
    }


    pub fn draw_new_keyframe(&mut self, message: &VisKeyFrameMsg) -> Result<(), Box<dyn std::error::Error>> {
        todo!()
    }

    pub fn draw_mappoints(&mut self, message: &VisMapPointsMsg) -> Result<(), Box<dyn std::error::Error>> {

        todo!()
    }

    pub fn draw_odometry() -> Result<(), Box<dyn std::error::Error>> {

        todo!()
    }


    pub fn send_image_to_frontend(&self, image: Mat) -> Result<(), Box<dyn std::error::Error>> {
        let actor = self.actor_system.find("TRACKING_FRONTEND").unwrap();
        actor.send(Box::new(
            ImageMsg {image}
        ))?;
        Ok(())
    }
}

pub enum VisualizeMsg {
    VisFeaturesMsg,
    VisKeyFrameMsg,
    VisMapPointsMsg
}

pub struct VisFeaturesMsg {
    pub keypoints: DVVectorOfKeyPoint,
}
impl ActorMessage for VisFeaturesMsg {}

pub struct VisKeyFrameMsg {
    pub pose: Pose,
}
impl ActorMessage for VisKeyFrameMsg {}

pub struct VisMapPointsMsg {}
impl ActorMessage for VisMapPointsMsg {}
